knitr::opts_chunk$set(echo = TRUE)
data = read.table ("w-gs1yr.txt",header = TRUE)
attach(data)
#create a time series object for the data
ir_ts = ts(rate, start = 1962+(5/365), freq = 52)
#display the plot, acf and pacf
tsdisplay(ir_ts, main = "Plot of weekly interest rate and its ACF and PACF")
setwd("/Users/Xiang/OneDrive/Desktop/Econ-144/Project/Project 2")
library(readr)
rm(list = ls(all=T))
data = read.csv('MSFTHistoricalQuotes.csv')
data1 = read.csv("AAPLHistoricalQuotes.csv")
attach(data)
attach(data1)
library(forecast)
msft_ts = ts(close, start = 2008+(149/365), freq = 252)
tsdisplay(msft_ts, main = "Plot of Microsoft's closing price and its ACF and PACF")
library(tseries)
library(stats)
#Since the data exhibits an upward sloping behavior, we can fit a quadratic model
t<-seq(2008+(149/365), 2018+(149/365),length=length(msft_ts))
model1 = tslm(msft_ts~t+I(t^2))
#Running the ACF and PACF to see if there are other dynamics that we have not taken care of
acf(model1$residuals, main = "Quadratic model's residuals' ACF")
pacf(model1$residuals, main = "Quadratic model's residuals PACF")
#we want to look at the residuals the quadratic model to see if we could still get rid of the dynamics. We tested using ARIMA model
#By first looking at the auto.arima function, we use ARIMA(3,1,3)
model2 = Arima(model1$residuals, order = c(3,0,3))
summary(model2)
tsdiag(model2)
#Alternatively, we could do an exponential smoothing model on the data
model3 = ets(msft_ts)
summary(model3)
#Since the AIC is smaller using the quadratic+ARIMA model, we'll use that instead
#Running the ACF and the PACF of the final residuals
acf(model2$resid, type = "correlation", main = "ARIMA(3,0,3)'s ACF")
pacf(model2$resid, main = "ARIMA(3,0,3)'s ACF")
Box.test(model2$resid[complete.cases(model2$resid)], lag = 100)
plot(msft_ts,model2$residuals, xlab = "Fitted Values", ylab = "Residuals", main = "Plot of Residuals vs fitted values")
qqnorm(as.numeric(model2$residuals), main = "QQPlot for the model 2's residual's values")
qqline(y, col = 2)
library(tseries)
library(stats)
#Since the data exhibits an upward sloping behavior, we can fit a quadratic model
t<-seq(2008+(149/365), 2018+(149/365),length=length(msft_ts))
model1 = tslm(msft_ts~t+I(t^2))
#Running the ACF and PACF to see if there are other dynamics that we have not taken care of
acf(model1$residuals, main = "Quadratic model's residuals' ACF")
pacf(model1$residuals, main = "Quadratic model's residuals PACF")
#we want to look at the residuals the quadratic model to see if we could still get rid of the dynamics. We tested using ARIMA model
#By first looking at the auto.arima function, we use ARIMA(3,1,3)
model2 = Arima(model1$residuals, order = c(3,0,3))
summary(model2)
tsdiag(model2)
#Alternatively, we could do an exponential smoothing model on the data
model3 = ets(msft_ts)
summary(model3)
#Since the AIC is smaller using the quadratic+ARIMA model, we'll use that instead
#Running the ACF and the PACF of the final residuals
acf(model2$resid, type = "correlation", main = "ARIMA(3,0,3)'s ACF")
pacf(model2$resid, main = "ARIMA(3,0,3)'s ACF")
Box.test(model2$resid[complete.cases(model2$resid)], lag = 100)
plot(msft_ts,model2$residuals, xlab = "Fitted Values", ylab = "Residuals", main = "Plot of Residuals vs fitted values")
qqnorm(as.numeric(model2$residuals), main = "QQPlot for the model 2's residual's values")
qqline(model2$residuals, col = 2)
setwd("/Users/Xiang/OneDrive/Desktop/Econ-144/Project/Project 2")
library(readr)
rm(list = ls(all=T))
data = read.csv('MSFTHistoricalQuotes.csv')
data1 = read.csv("AAPLHistoricalQuotes.csv")
attach(data)
attach(data1)
library(forecast)
msft_ts = ts(close, start = 2008+(149/365), freq = 252)
tsdisplay(msft_ts, main = "Plot of Microsoft's closing price and its ACF and PACF")
library(tseries)
library(stats)
#Since the data exhibits an upward sloping behavior, we can fit a quadratic model
t<-seq(2008+(149/365), 2018+(149/365),length=length(msft_ts))
model1 = tslm(msft_ts~t+I(t^2))
#Running the ACF and PACF to see if there are other dynamics that we have not taken care of
acf(model1$residuals, main = "Quadratic model's residuals' ACF")
pacf(model1$residuals, main = "Quadratic model's residuals PACF")
#we want to look at the residuals the quadratic model to see if we could still get rid of the dynamics. We tested using ARIMA model
#By first looking at the auto.arima function, we use ARIMA(3,1,3)
model2 = Arima(model1$residuals, order = c(3,0,3))
summary(model2)
tsdiag(model2)
#Alternatively, we could do an exponential smoothing model on the data
model3 = ets(msft_ts)
summary(model3)
#Since the AIC is smaller using the quadratic+ARIMA model, we'll use that instead
#Running the ACF and the PACF of the final residuals
acf(model2$resid, type = "correlation", main = "ARIMA(3,0,3)'s ACF")
pacf(model2$resid, main = "ARIMA(3,0,3)'s ACF")
Box.test(model2$resid[complete.cases(model2$resid)], lag = 100)
plot(msft_ts,model2$residuals, xlab = "Fitted Values", ylab = "Residuals", main = "Plot of Residuals vs fitted values")
qqnorm(as.numeric(model2$residuals), main = "QQPlot for the model 2's residual's values")
qqline(model2$residuals, col = 2)
library(strucchange)
library(vars)
y=recresid(model2$res~1)
plot(y, pch=16,ylab="Recursive Residuals")
plot(efp(model2$res~1, type = "Rec-CUSUM"), plot.type="single")
forecasted_val = forecast(model2, h = 12)
plot(forecasted_val, main = "Forecast based on my model", xlab = 'Time', ylab = 'Forecasted values', shadecols = "oldstyle", xlim = c(2018.4,2018.6))
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
# Use var.select
y_model=VAR(y_tot,p=3)
summary(y_model)
View(aapl_ts)
view(msft_ts)
library(readr)
rm(list = ls(all=T))
data = read.csv('MSFTHistoricalQuotes.csv')
data1 = read.csv("AAPLHistoricalQuotes.csv")
attach(data)
library(forecast)
msft_ts = ts(close, start = 2008+(149/365), freq = 252)
tsdisplay(msft_ts, main = "Plot of Microsoft's closing price and its ACF and PACF")
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
# Use var.select
y_model=VAR(y_tot,p=3)
summary(y_model)
y_model=VAR.select(y_tot,p=3)
summary(y_model)
y_model=VAR.select(y_tot,p=10)
summary(y_model)
help(VAR.select)
y_model$IC
BIC(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
# Use var.select
y_model=VAR(y_tot,p=3)
summary(y_model)
AIC(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
AIC(y_model)
BIC(y_model)
}
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
AIC(y_model)
BIC(y_model)
}
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(AIC(y_model))
print(BIC(y_model))
}
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
tsdisplay(residuals(y_model),main ="")
tsdisplay(residuals(y_model),main ="")
tsdisplay(residuals(y_model)[,2],main ="")
tsdisplay(residuals(y_model)[,1],main ="Plot of Microsoft residuals and its corresponding ACF and PACF")
tsdisplay(residuals(y_model)[,2],main ="Plot of Apple residuals and its corresponding ACF and PACF")
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=1)
summary(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=4)
summary(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=7)
summary(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=1)
summary(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=3)
summary(y_model)
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=2)
summary(y_model)
tsdisplay(residuals(y_model)[,1],main ="Plot of Microsoft residuals and its corresponding ACF and PACF")
tsdisplay(residuals(y_model)[,2],main ="Plot of Apple residuals and its corresponding ACF and PACF")
tsdiag(residuals(y_model)[,1],main ="Plot of Microsoft residuals and its corresponding ACF and PACF")
tsdiag(y_model,main ="Plot of Microsoft residuals and its corresponding ACF and PACF")
plot(y_model)
plot(y_model)
plot(y_model)
plot(y_model)
plot(y_model[,1])
windows()
plot(y_model)
y_model$obs
y_model$varresult
tsdisplay(residuals(y_model)[,1],main ="Plot of Microsoft's residuals and its ACF and PACF")
tsdisplay(residuals(y_model)[,2],main ="Plot of Apple's residuals and its ACF and PACF")
tsdisplay(residuals(y_model)[,1],main ="Plot of Microsoft's residuals and its ACF and PACF")
tsdisplay(residuals(y_model)[,2],main ="Plot of Apple's residuals and its ACF and PACF")
Box.test(residuals(y_model)[,1], lag = 1000)
help(tsdiag)
tsdiag(residuals(y_model)[,1])
residuals(y_model)[,1]
irf(y_model)
plot(irf(y_model))
grangertest(msft_ts ~ aapl_ts, order = 2)
grangertest(aapl_ts,~ msft_ts, order = 2)
grangertest(msft_ts ~ aapl_ts, order = 2)
grangertest(aapl_ts~ msft_ts, order = 2)
var_predict <- predict(object = y_model, n.ahead = 12)
quartz()
var_predict <- predict(object = y_model, n.ahead = 12)
plot(var_predict)
library(ggplot2)
var_predict <- predict(object = y_model, n.ahead = 12)
plot(var_predict, xlim = c(2515,2540))
library(ggplot2)
var_predict <- predict(object = y_model, n.ahead = 12)
plot(var_predict)
library(ggplot2)
var_predict <- predict(y_model, n.ahead = 12)
plot(var_predict)
library(ggplot2)
var_predict <- forecast(y_model, h = 12)
library(ggplot2)
var_predict <- predict(y_model, n.ahead = 12)
plot(var_predict)
library(ggplot2)
var_predict <- predict(y_model, n.ahead = 12)
plot(var_predict, xlim = c(2515,2540))
View(data)
View(data)
var_predict
forecasted_val
setwd("/Users/Xiang/OneDrive/Desktop/Econ-144/Project/Project 2")
library(readr)
rm(list = ls(all=T))
data = read.csv('MSFTHistoricalQuotes.csv')
data1 = read.csv("AAPLHistoricalQuotes.csv")
attach(data)
library(forecast)
msft_ts = ts(close, start = 2008+(149/365), freq = 252)
tsdisplay(msft_ts, main = "Plot of Microsoft's closing price and its ACF and PACF")
library(tseries)
library(stats)
#Since the data exhibits an upward sloping behavior, we can fit a quadratic model
t<-seq(2008+(149/365), 2018+(149/365),length=length(msft_ts))
model1 = tslm(msft_ts~t+I(t^2))
#Running the ACF and PACF to see if there are other dynamics that we have not taken care of
acf(model1$residuals, main = "Quadratic model's residuals' ACF")
pacf(model1$residuals, main = "Quadratic model's residuals PACF")
#we want to look at the residuals the quadratic model to see if we could still get rid of the dynamics. We tested using ARIMA model
#By first looking at the auto.arima function, we use ARIMA(3,1,3)
model2 = Arima(model1$residuals, order = c(3,0,3))
summary(model2)
tsdiag(model2)
#Alternatively, we could do an exponential smoothing model on the data
model3 = ets(msft_ts)
summary(model3)
#Since the AIC is smaller using the quadratic+ARIMA model, we'll use that instead
#Running the ACF and the PACF of the final residuals
acf(model2$resid, type = "correlation", main = "ARIMA(3,0,3)'s ACF")
pacf(model2$resid, main = "ARIMA(3,0,3)'s ACF")
Box.test(model2$resid[complete.cases(model2$resid)], lag = 100)
plot(msft_ts,model2$residuals, xlab = "Fitted Values", ylab = "Residuals", main = "Plot of Residuals vs fitted values")
qqnorm(as.numeric(model2$residuals), main = "QQPlot for the model 2's residual's values")
qqline(model2$residuals, col = 2)
library(strucchange)
library(vars)
y=recresid(model2$res~1)
plot(y, pch=16,ylab="Recursive Residuals")
plot(efp(model2$res~1, type = "Rec-CUSUM"), plot.type="single")
forecasted_val = forecast(model2, h = 12)
plot(forecasted_val, main = "Forecast based on my model", xlab = 'Time', ylab = 'Forecasted values', shadecols = "oldstyle", xlim = c(2018.4,2018.6))
library(vars)
library(VAR.etp)
aapl_ts = ts(data1$close, start = 2008+(149/365), freq = 252)
y=cbind(msft_ts, aapl_ts)
y_tot=data.frame(y)
# To fit a VAR(p) model, simply call 'VAR' and set p=value
for (i in 1:10){
y_model=VAR(y_tot,p=i)
print(paste("AIC and BIC for order",as.numeric(i)))
print(AIC(y_model))
print(BIC(y_model))
}
y_model = VAR(y_tot, p=2)
summary(y_model)
tsdisplay(residuals(y_model)[,1],main ="Plot of Microsoft's residuals and its ACF and PACF")
tsdisplay(residuals(y_model)[,2],main ="Plot of Apple's residuals and its ACF and PACF")
plot(irf(y_model))
grangertest(msft_ts ~ aapl_ts, order = 2)
grangertest(aapl_ts~ msft_ts, order = 2)
library(ggplot2)
var_predict <- predict(y_model, n.ahead = 12)
plot(var_predict, xlim = c(2515,2540))
forecasted_val
